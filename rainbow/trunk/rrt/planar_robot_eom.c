#include "mex.h"
#include <ctype.h> 
#include <math.h>  
#include <stdarg.h>
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>

/* Degrees to radians conversion */
#define Pi			3.14159265358979323846264338327950288419716939937510582
#define DEGtoRAD	0.01745329251994329576923690768488612713442871888541725
#define	RADtoDEG	57.2957795130823208767981548141051703324054724665643215
#define G			9.81
#define _NAN        9.99E+305

void     define(const double *Torque, const double *Q, const double *U, const double *Theta);
void	 evaluate(void);
void     output(double Up[]);

double   BETA,C1,C2,C3,G,IB2,IC2,ID2,IE2,IF2,MB,MC,MD,ME,MF,V1,V2,V3,Q1,Q2,Q3,T1,T2,T3,U1,U2,U3;
double   TF1,TF2,TF3,U1p,U2p,U3p;
double   z[126];

/* ................................ MAIN ............................. */
void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
	int nrows = 3; int ncols = 1;
	int ii, jj, n; int m = 0;
	double *Torque, *Q, *U, *Theta;
	double *Up;

    /* Assign pointers to each input and output. */
	Torque = mxGetPr(prhs[0]);
	Q  = mxGetPr(prhs[1]);
	U = mxGetPr(prhs[2]);
	Theta = mxGetPr(prhs[3]);
    if (mxGetM(prhs[0]) != 3)
    {
        mexErrMsgTxt("Not enough torques specified.");
    }

    if (mxGetM(prhs[1]) != 3)
    {
        mexErrMsgTxt("Not enough Qs specified.");
    }

    if (mxGetM(prhs[2]) != 3)
    {
        mexErrMsgTxt("Not enough Qps specified.");
    }

    if (mxGetM(prhs[3]) != 14)
    {
        mexErrMsgTxt("Not enough arguments specified for theta vector.");
    }
	
	/* Evaluate output quantities */
	define(Torque,Q,U,Theta);
	evaluate();
	
   	/* Create matrix for the return argument. */
	plhs[0] = mxCreateDoubleMatrix(nrows,ncols, mxREAL);
	Up = mxGetPr(plhs[0]);

    output(Up);
}

/* ............................. DEFINITIONS ........................... */

void define(const double *Torque, const double *Q, const double *U, const double *Theta)
{
	// define joint torques from input
	T1 = Torque[0];
	T2 = Torque[1];
	T3 = Torque[2];

	// define joint angles from input
	Q1 = Q[0];
	Q2 = Q[1];
	Q3 = Q[2];
	
	// define joint velocities from input
	U1 = U[0];
	U2 = U[1];
	U3 = U[2];
	
	// define robot parameters from theta
	G = 9.81;
    MB = Theta[];
	MC = Theta[];
	MD = Theta[];
	ME = Theta[];
	MF = Theta[];
	IB2 = Theta[];
	IC2 = Theta[];
	ID2 = Theta[];
	IE2 = Theta[];
	IF2 = Theta[];
    C1 = Theta[7];
    C2 = Theta[8];
    C3 = Theta[9];
    V1 = Theta[10];
    V2 = Theta[11];
    V3 = Theta[12];
    BETA = Theta[13];
}

/* ................................ OUTPUT ............................. */

void output(double Up[])
{
	Up[0]=U1p;
	Up[1]=U2p;
	Up[2]=U3p;
}

/* ................................ EQNS .............................. */

void evaluate(void)
{
/* Evaluate constants */
  z[3] = cos(Q2);
  z[4] = sin(Q2);
  z[8] = pow(z[3],2) + pow(z[4],2);
  z[1] = cos(Q1);
  z[2] = sin(Q1);
  z[7] = pow(z[1],2) + pow(z[2],2);
  z[71] = IC2*z[8];
  z[75] = ID2*z[8];
  z[80] = IE2*z[8];
  z[86] = IF2*z[8];
  z[20] = z[3]*z[7];
  z[22] = 0.0485*z[7] + 0.45*z[20];
  z[23] = 0.45*z[20] + 0.48*z[7];
  z[24] = z[23] - 0.1122*z[7];
  z[6] = sin(Q3);
  z[5] = cos(Q3);
  z[21] = z[4]*z[7];
  z[27] = z[6]*z[23] + 0.45*z[5]*z[21];
  z[28] = z[6]*z[8];
  z[26] = z[5]*z[23] - 0.45*z[6]*z[21];
  z[29] = z[26] - 0.042*z[7];
  z[25] = z[5]*z[8];
  z[30] = 0.48*z[25] - 0.042*z[8];
  z[31] = z[26] + 0.07000000000000001*z[7];
  z[33] = z[31] - 0.048*z[7];
  z[32] = 0.07000000000000001*z[8] + 0.48*z[25];
  z[34] = z[32] - 0.048*z[8];
  z[89] = z[7]*z[71] + z[7]*z[75] + z[7]*z[80] + z[7]*z[86] + 0.0485*MC*z[8]*
  z[22] + 0.3678*MD*z[8]*z[24] + 0.48*ME*(z[27]*z[28]+2.083333333333333*z[29]*
  z[30]) + 0.48*MF*(z[27]*z[28]+2.083333333333334*z[33]*z[34]);
  z[9] = pow(z[5],2) + pow(z[6],2);
  z[81] = IE2*z[9];
  z[87] = IF2*z[9];
  z[98] = z[9]*(2066.115702479338*z[81]+2066.115702479338*z[87]+MF*z[9]+
  3.644628099173552*ME*z[9]);
  z[90] = z[7]*z[81] + z[7]*z[87] + 0.02200000000000001*MF*z[9]*z[33] - 0.042*
  ME*z[9]*z[29];
  z[97] = z[9]*(1.909090909090908*ME*z[30]-45.45454545454544*z[80]-45.45454545454544*
  z[86]-MF*z[34]);
  z[111] = 0.0004840000000000003*z[89]*z[98] + 0.02200000000000001*z[90]*
  z[97];
  z[79] = IE2*z[7];
  z[85] = IF2*z[7];
  z[96] = z[9]*(1.909090909090908*ME*z[29]-45.45454545454544*z[79]-45.45454545454544*
  z[85]-MF*z[33]);
  z[94] = z[8]*z[81] + z[8]*z[87] + 0.02200000000000001*MF*z[9]*z[34] - 0.042*
  ME*z[9]*z[30];
  z[93] = z[8]*z[71] + z[8]*z[75] + z[8]*z[80] + z[8]*z[86] + 0.00235225*MC*
  pow(z[8],2) + 0.13527684*MD*pow(z[8],2) + 0.2304*ME*(pow(z[28],2)+4.340277777777778*
  pow(z[30],2)) + 0.2304*MF*(pow(z[28],2)+4.340277777777778*pow(z[34],2));
  z[106] = z[89]*z[94] - z[90]*z[93];
  z[67] = IB2*z[7];
  z[70] = IC2*z[7];
  z[74] = ID2*z[7];
  z[88] = z[7]*z[67] + z[7]*z[70] + z[7]*z[74] + z[7]*z[79] + z[7]*z[85] + 
  0.01754100000000001*MB*pow(z[7],2) + MF*(pow(z[27],2)+pow(z[33],2)) + 
  0.2025*MC*(pow(z[21],2)+4.93827160493827*pow(z[22],2)) + 0.2025*MD*(pow(
  z[21],2)+4.938271604938271*pow(z[24],2)) + 0.9999999999999999*ME*(pow(z[29],
  2)+1*pow(z[27],2));
  z[92] = z[8]*z[70] + z[8]*z[74] + z[8]*z[79] + z[8]*z[85] + 0.0485*MC*z[8]*
  z[22] + 0.3678*MD*z[8]*z[24] + 0.48*ME*(z[27]*z[28]+2.083333333333333*z[29]*
  z[30]) + 0.48*MF*(z[27]*z[28]+2.083333333333333*z[33]*z[34]);
  z[105] = z[88]*z[94] - z[90]*z[92];
  z[104] = z[88]*z[93] - z[89]*z[92];
  z[107] = 0.02200000000000001*z[96]*z[106] - 0.02200000000000001*z[97]*
  z[105] - 0.0004840000000000003*z[98]*z[104];
  z[115] = z[8]*z[111]/z[107];
  z[108] = 0.0004840000000000003*z[93]*z[98] + 0.02200000000000001*z[94]*
  z[97];
  z[114] = z[7]*z[108]/z[107];
  z[116] = z[9]*z[106]/z[107];
  z[50] = G*ME;
  z[54] = -z[1]*z[4] - z[2]*z[3];
  z[57] = z[1]*z[3] - z[2]*z[4];
  z[60] = z[5]*z[54] - z[6]*z[57];
  TF3 = V3*U3 + C3*tanh(BETA*U3);
  z[51] = G*MF;
  z[66] = z[9]*(1.909090909090909*z[50]*z[60]-45.45454545454545*TF3-z[51]*
  z[60]);
  z[99] = 1.909090909090908*ME - MF;
  z[10] = z[7]*U1;
  z[35] = pow(z[10],2);
  z[36] = z[4]*z[35];
  z[37] = z[3]*z[35];
  z[11] = z[8]*U2;
  z[39] = -0.45*z[37] - 0.48*(z[7]*U1+z[8]*U2)*(z[10]+z[11]);
  z[41] = 0.45*z[5]*z[36] - z[6]*z[39];
  z[100] = z[99]*z[9]*z[41];
  z[103] = 0.02200000000000001*z[66] + 0.02200000000000001*z[100];
  TF2 = V2*U2 + C2*tanh(BETA*U2);
  TF1 = V1*U1 + C1*tanh(BETA*U1);
  z[63] = z[5]*z[57] + z[6]*z[54];
  z[47] = G*MB;
  z[48] = G*MC;
  z[49] = G*MD;
  z[64] = -TF2*z[7] - (TF1-TF2)*z[7] - z[50]*(z[27]*z[63]+z[29]*z[60]) - 
  z[51]*(z[27]*z[63]+z[33]*z[60]) - 0.03*z[47]*z[7]*(z[1]-4.300000000000001*
  z[2]) - 0.45*z[48]*(z[21]*z[57]+2.222222222222222*z[22]*z[54]) - 0.45*z[49]*(
  z[21]*z[57]+2.222222222222222*z[24]*z[54]);
  z[42] = z[5]*z[39] + 0.45*z[6]*z[36];
  z[12] = z[9]*U3;
  z[44] = z[42] - 0.07000000000000001*(z[7]*U1+z[8]*U2+z[9]*U3)*(z[10]+z[11]+
  z[12]);
  z[45] = z[44] + 0.048*(z[7]*U1+z[8]*U2+z[9]*U3)*(z[10]+z[11]+z[12]);
  z[38] = -0.45*z[37] - 0.0485*(z[7]*U1+z[8]*U2)*(z[10]+z[11]);
  z[40] = z[39] + 0.1122*(z[7]*U1+z[8]*U2)*(z[10]+z[11]);
  z[43] = z[42] + 0.042*(z[7]*U1+z[8]*U2+z[9]*U3)*(z[10]+z[11]+z[12]);
  z[91] = MF*(z[27]*z[45]+z[33]*z[41]) + 0.4500000000000001*MC*(z[21]*z[38]+
  z[22]*z[36]) + 0.45*MD*(z[24]*z[36]+1*z[21]*z[40]) + 0.9999999999999999*ME*(
  z[29]*z[41]+1*z[27]*z[43]) - 4.336808689942018E-19*MB*z[7]*z[35];
  z[101] = z[64] - z[91];
  z[65] = -TF2*z[8] - 0.3678*z[49]*z[8]*z[54] - 0.0485*z[48]*z[8]*z[54] - 
  0.48*z[50]*(z[28]*z[63]+2.083333333333334*z[30]*z[60]) - 0.48*z[51]*(z[28]*
  z[63]+2.083333333333334*z[34]*z[60]);
  z[95] = 0.021825*MC*z[8]*z[36] + 0.16551*MD*z[8]*z[36] + 0.48*ME*(z[28]*
  z[43]+2.083333333333333*z[30]*z[41]) + 0.48*MF*(z[28]*z[45]+2.083333333333333*
  z[34]*z[41]);
  z[102] = z[65] - z[95];
  z[117] = (z[106]*z[103]+z[108]*z[101]-z[111]*z[102])/z[107];
  U1p = T2*z[115] - T1*z[114] - T3*z[116] - z[117];
  z[109] = 0.0004840000000000003*z[92]*z[98] + 0.02200000000000001*z[94]*
  z[96];
  z[118] = z[7]*z[109]/z[107];
  z[120] = z[9]*z[105]/z[107];
  z[112] = 0.0004840000000000003*z[88]*z[98] + 0.02200000000000001*z[90]*
  z[96];
  z[121] = (z[105]*z[103]+z[109]*z[101]-z[112]*z[102])/z[107];
  z[119] = z[8]*z[112]/z[107];
  U2p = T1*z[118] + T3*z[120] + z[121] - T2*z[119];
  z[113] = 0.02200000000000001*z[89]*z[96] - 0.02200000000000001*z[88]*z[97];
  z[123] = z[8]*z[113]/z[107];
  z[110] = 0.02200000000000001*z[93]*z[96] - 0.02200000000000001*z[92]*z[97];
  z[122] = z[7]*z[110]/z[107];
  z[124] = z[9]*z[104]/z[107];
  z[125] = (z[104]*z[103]+z[110]*z[101]-z[113]*z[102])/z[107];
  U3p = T2*z[123] - T1*z[122] - T3*z[124] - z[125];
}

